<html>
  <head>
    <meta charset="utf-8" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js"
        }
      }
    </script>
    <script typt="text/javascript" src="field_guide.js"> </script>

    <script type="module">
      import * as THREE from "three";

      const renderer = new THREE.WebGLRenderer({
        canvas: document.querySelector("#myCanvas"),
      });
      let height = window.innerHeight / 2.0;
      let width = window.innerWidth - 16;
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize( width, height );
      // document.body.appendChild( renderer.domElement );
      let ctrl_info = {};
      ctrl_info.i_height = height;
      ctrl_info.i_width = width;


      let to_camera = {};
      to_camera.x = 0; 
      to_camera.y = 0;
      to_camera.z = 100;
      const camera = new THREE.PerspectiveCamera( 45, width / height, 1, 500 );
      console.log("幅:" + height);
      camera.position.set( to_camera.x, to_camera.y, to_camera.z );
      camera.lookAt( 0, 0, 0 );


      const scene = new THREE.Scene();
      const material = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth:2 } );
      let line = null;
      let field_guide = {};

      function unitVec(vec) {
        let r = Math.sqrt(vec.x * vec.x + vec.y * vec.y);
        return {x: (vec.x / r), y: (vec.y / r), r : r};
      }

      field_guide.updateLine = function(p) {
        ctrl_info.p = p;
        scene.remove(line);
        console.log("点数：" + p.length);
        const lpoints = [];
        let sum_x = 0;
        let sum_y = 0;
        for (let i = 0; i < p.length; i++) {
          console.log("x:" + p[i][0] + ", y:" + p[i][1]);
          sum_x += p[i][0];
          sum_y += p[i][1];
        }
        let center_x = sum_x / p.length;
        let center_y = sum_y / p.length;
        to_camera.x = center_x;
        to_camera.y = center_y;
        console.log("カメラx：" + sum_x);
        to_camera.cx = center_x;
        to_camera.cy = center_y;

        let max = 0;
        for (let i = 0; i < p.length; i++) {
          console.log("x:" + p[i][0] + ", y:" + p[i][1]);
          let mx = Math.abs(p[i][0] - center_x);
          let my = Math.abs(p[i][1] - center_y);
          if (max < mx) {
            max = mx;
          }
          if (max < my) {
            max = my;
          }
          to_camera.mx = mx;
          to_camera.my = my;
          to_camera.my = max;
          console.log("マックス：" + max);
          if (width > height) {
            to_camera.z = height * max / height * 3;
          } else {
            to_camera.z = width * max / width * 3;
          }
          if (to_camera.z < 20) {
            to_camera.z = 20;
          }
          if (to_camera.z > 400) {
            to_camera.z = 400;
          }
          lpoints.push( new THREE.Vector3(p[i][0], p[i][1], p[i][2]) );
        }
        const geometry = new THREE.BufferGeometry().setFromPoints( lpoints );
        line = new THREE.Line( geometry, material );
        scene.add( line );

        let cur_x = p[p.length - 1][0];
        let cur_y = p[p.length - 1][1];
        cursor.position.set(cur_x, cur_y);

        let vec = { x:(to_camera.x - cur_x), y:(to_camera.y - cur_y)};
        vec = unitVec(vec);
        if (vec.r > 160) {
          vec.r = 160;
          to_camera.x = cur_x + vec.r * vec.x;
          to_camera.y = cur_y + vec.r * vec.y;
        }
        renderer.render( scene, camera );
      };
      field_guide.updateToCamera = function(x, y, z) {
        to_camera.x = x;
        to_camera.y = y;
        to_camera.z = z;        
      }
      field_guide.getInfo = function() {
        return { "カメラ位置" : to_camera, "制御情報" : ctrl_info };
      }

      let cur_geo = new THREE.IcosahedronGeometry(2, 0);
      // let cur_geo = new THREE.BoxGeometry(40, 40, 40);
      // const cur_material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
      const cur_material = new THREE.MeshNormalMaterial();
      // const cur_material = new THREE.MeshToonMaterial( { color: 0xffffff } );
      let cursor = new THREE.Mesh(cur_geo, cur_material);
      // cursor.receiveShadow = true;
      scene.add(cursor);
      // 点光源
      let light = new THREE.PointLight(0xFFFFFF, 10, 16, 1.0);
      scene.add(light);

      // 地面を作成
      const plane = new THREE.GridHelper(3000, 300, 0x888888, 0x888888);
      // plane.position.y = -100;
      plane.rotation.x = Math.PI / 2;  
      scene.add(plane);


      const points = [];
      points.push([-10, 0, 0]);
      points.push([0, 10, 0 ]);
      points.push([10, 0, 0 ]);
      field_guide.updateLine(points);


      window.onload = function() {
        start_field_guide(field_guide);
      }


      tick();
      function tick() {
        cursor.rotation.y -= 0.03;
        cursor.rotation.z -= 0.06;
        light.position.set(0, 0, 3)
        let fx = camera.position.x;
        let fy = camera.position.y;
        let fz = camera.position.z;
        let tx = fx - (fx - to_camera.x) / 100;
        let ty = fy - (fy - to_camera.y) / 100;
        let tz = fz - (fz - to_camera.z) / 100;
        
        camera.position.set(tx, ty, tz);
        camera.lookAt(tx, ty, 0);
        renderer.render(scene, camera); // レンダリング
        requestAnimationFrame(tick);
      }

</script>
  </head>
  <body>
    <canvas id="myCanvas"></canvas>
    <textarea id="result" style="width: 100%;" rows="16">
      {
        "経路" :[]
      }
          </textarea>
    <input id="idokeido" placeholder="緯度,経度" /><button id="addIdoKeido">経路追加</button>
    <button id="update">更新</button>
    <input id="to_camera" placeholder="x, y, z" value="0, 0, 100"/>
    <button id="btn_to_camera">カメラ位置</button>
    <button id="btn_get_info">制御情報表示</button>
    <textarea id="control_info" style="width: 100%;" rows="16">
    </textarea>
  </body>
</html>